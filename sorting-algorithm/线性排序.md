### 前言
线性排序算法就三个：
- 桶排序
- 计数排序
- 基数排序

**线性排序算法的时间复杂度为O(n)**。线性排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。

### 桶排序
#### 原理
1. 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序（或者归并排序）。
2. 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

#### 适用条件
1. 要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。
2. 数据在各个桶之间分布是均匀的。

#### 代码实例
假设数据：[1,7,8,24,19,46,26,38,33,12,42,20,6,35]，使用桶排序。
观察发现，这里可以分为5个桶，分别标号为：0，1，2，3，4，这5个桶，0号放小于10的数，1号放大于等于10小于20的数，依次类推。
将数字放到不同的桶里后，桶里可以使用快速排序。
[代码实现：](src/bucket_sort.py)
```python
def sort(arr):
    #将数据分到5个桶中
    buckets = [[],[],[],[],[]]
    for index in range(len(arr)):
        bucket_no = arr[index] // 10
        buckets[bucket_no].append(arr[index])
    
    for index in range(len(buckets)):
        buckets[index].sort()
        print(buckets[index])

if __name__ == '__main__':
    arr = [1,7,8,24,19,46,26,38,33,12,42,20,6,35]
    sort(arr)
```

运行结果：
```
[1, 6, 7, 8]
[12, 19]
[20, 24, 26]
[33, 35, 38]
[42, 46]
```

#### 应用案例
1.需求描述：
有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序，但内存有限，仅几百MB。
2.解决思路：
扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。
第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。

每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。
将100个小文件依次放入内存并用快排排序。
所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。
注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。

#### 时间复杂度
我们假设有n个待排序数字。分到m个桶中，如果分配均匀这样平均每个桶有n/m个元素。桶排序的算法时间复杂度有两部分组成：
1. 遍历处理每个元素，O(n)级别的普通遍历
2. 每个桶内再次排序的时间复杂度总和

这里看桶内排序总的时间复杂度：
如果桶内元素分配较为均匀假设每个桶内部使用的排序算法为快速排序，那么每个桶内的时间复杂度为(n/m)log(n/m)。有m个桶，那么时间复杂度为m * (n/m)log(n/m)=n(log(n)-log(m)).

所有总的时间复杂度为:O(n)+n(log(n)-log(m))。

当n与m趋近与相等时，时间复杂度即为O(n)
